// # -*- mode: c -*-
/* File: proj_functions.c.src */
/*
  This file is a part of the Corrfunc package
  Copyright (C) 2015-- Manodeep Sinha (manodeep@gmail.com)
  License: MIT LICENSE. See LICENSE file under the top-level
  directory at https://github.com/manodeep/Corrfunc/
*/

#ifndef DOUBLE_PREC
#define DOUBLE_PREC
#endif
// # -*- mode: c -*-
#pragma once

#include "proj_functions_DOUBLE.h"

#include "defs.h"
#include "utils.h"

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#include <gsl/gsl_matrix_DOUBLE.h>
#include <gsl/gsl_linalg.h>
#include <gsl/gsl_interp.h>


//////////////////////////////////
// Projection functions
//////////////////////////////////

void tophat_DOUBLE(const proj_struct_DOUBLE *proj, DOUBLE *u, DOUBLE sqr_s){
    int ins = -1;
    for(int p=0;p<proj->nsbins;p++){
        u[p] = 0;
        if (sqr_s >= proj->supp_sqr[p] && sqr_s < proj->supp_sqr[p+1]){
            ins = p;
        }
    }
    if (ins>=0 && ins<proj->nprojbins){
        u[ins] = 1.0;
    }
}


void piecewise_DOUBLE(const proj_struct_DOUBLE *proj, DOUBLE *u, DOUBLE sqr_s){

    // Assumes nsbins = nprojbins
    for(int p=0;p<proj->nprojbins;p++){

        // peaks are bin averages, for now - need to take square roots
        double peak = 0.5*(sqrt(proj->supp_sqr[p]) + sqrt(proj->supp_sqr[p+1]));
        // assumes bins in ascending order
        double binwidth = sqrt(proj->supp_sqr[p+1]) - sqrt(proj->supp_sqr[p]);
        double val = 1.0 - (1.0/binwidth) * fabs(sqrt(sqr_s) - peak);
        if (val < 0) {
            val = 0;
        }
        u[p] = val;

    }
}


//  void gaussian_kernel_DOUBLE(const proj_struct_DOUBLE *proj, DOUBLE *u, DOUBLE sqr_s){
//      //printf("Gaussian kernel\n");
//      DOUBLE s = sqrt(sqr_s);
//      int nbases = proj->nbases;
//      int nres = proj->nres;
//      DOUBLE sval;
//  
//      // TODO: somewhere check that r is in ascending order
//      /* naive search, TODO replace w binary */
//      int i0 = -1, i1 = -1;
//      int i_closest;
//      DOUBLE s0, s1, y0, y1, sp;
//      for(int p=0;p<proj->nprojbins;p++){
//        sp = sqrt(proj->supp_sqr[p]);
//        // step through radii until desired value is less than radius
//        if (s <= sp) {
//          i0 = p-1; //index before insertion location
//          i1 = p; //index after insertion location
//          s0 = sqrt(proj->supp_sqr[p-1]); //TODO: not sure this is safe for out-of-range r
//          s1 = sp;
//          if (abs(s-s0)<abs(s-s1)){
//              i_closest = i0;
//          }
//          else{
//              i_closest = i1;
//          }
//          break;
//        }
//      }
//      for (int p=0; p<proj->nprojbins; p++){
//          u[p] = 0;
//      }
//  
//      if (i0 != -1) {
//        int ncent = (nres-1)/2;
//        int j = 0; //first and only basis
//        int i_neg, i_pos;
//        DOUBLE y_neg, y_pos;
//        u[i_closest] = proj->projbases[ncent*(nbases+1)+(j+1)];
//        for (int n=1; n<ncent+1; n++){
//          // +1's because 0th column is sarr
//          i_neg = ncent-n;
//          i_pos = ncent+n; 
//          y_neg = proj->projbases[i_neg*(nbases+1)+(j+1)];
//          y_pos = proj->projbases[i_pos*(nbases+1)+(j+1)];
//          if (i_closest-n >= 0){
//              u[i_closest-n] = y_neg;
//          }
//          if (i_closest+n < proj->nprojbins){
//              u[i_closest+n] = y_pos;
//          }
//        }
//      }
//  }

void gaussian_kernel_DOUBLE(const proj_struct_DOUBLE *proj, DOUBLE *u, DOUBLE sqr_s){
   //printf("Gaussian kernel\n");
   double sigma = 3.0;
   double s = sqrt(sqr_s);
   double amp = 1.0/(sqrt(2.0*M_PI)*sigma);
   for(int p=0;p<proj->nprojbins;p++){
       double rp = sqrt(proj->supp_sqr[p]);
       if (abs(rp-s)<4.0*sigma) {
           double gaussian = amp * exp( -0.5* pow((rp-s) / sigma, 2.0));
           u[p] = gaussian;
       }
       else {
           u[p] = 0;
       }
   }
}

void powerlaw_DOUBLE(const proj_struct_DOUBLE *proj, DOUBLE *u, DOUBLE sqr_s){

    double s = sqrt(sqr_s);
    
    double gamma=2.7, s0=15.0;
    double powlaw = pow(s/s0, -1*gamma);
    u[0] = powlaw;

    double amp=0.004, width=10, mean=107;
    double bump = amp * exp(-1*pow(s-mean,2)/(2*pow(width,2)));
    u[1] = bump;
   
    double dwidth = amp*pow(s-mean,2)/pow(width,3) * exp(-1*pow(s-mean,2)/(2*pow(width,2))); 
    u[2] = dwidth;
}



void general_r_DOUBLE(const proj_struct_DOUBLE *proj, DOUBLE *u, DOUBLE sqr_s){

    DOUBLE s = sqrt(sqr_s);
    int nbases = proj->nbases;
    int nres = proj->nres;
    DOUBLE sval;

    // TODO: somewhere check that r is in ascending order
    /* naive search, TODO replace w binary */
    int i0 = -1, i1 = -1;
    DOUBLE s0, s1, y0, y1;
    for (int i=0; i<nres; i++){
      // get first colum of basis file, radii
      sval = proj->projbases[i*(nbases+1)];
      if (s <= sval) {
        //idx = i-1; //index before insertion location
        i0 = i-1;
        i1 = i;
        s0 = proj->projbases[i0*(nbases+1)];
        s1 = sval;

        break;
      } 
    }
    // if not in r range, return 0s
    // TODO: better to send an array of 0's and just return?
    if (i0==-1){
      for (int j=0; j<nbases; j++){
        u[j] = 0;
      }
    }
    else {
      for (int j=0; j<nbases; j++){
        // +1's because 0th column is sarr 
        y0 = proj->projbases[i0*(nbases+1)+(j+1)];
        y1 = proj->projbases[i1*(nbases+1)+(j+1)];
        u[j] = y0 + (s - s0)*(y1 - y0)/(s1 - s0); //linear interp
      }
    } 
}

//////////////////////////////////
// Utility functions
//////////////////////////////////

/* Gives a pointer to the projection function for the given projection method
 * and instruction set.
 */
proj_func_t_DOUBLE get_proj_func_by_method_DOUBLE(const proj_method_t method){
    switch(method){
        case TOPHAT:
            return &tophat_DOUBLE;
        case PIECEWISE:
            return &piecewise_DOUBLE;
        case POWERLAW:
            return &powerlaw_DOUBLE;
        case GENR:
            return &general_r_DOUBLE;
        case GAUSSIAN_KERNEL:
            return &gaussian_kernel_DOUBLE;
        default:
        case NONEPROJ:
            return NULL;
    }
}

int compute_amplitudes_DOUBLE(int nprojbins, int nd1, int nd2, int nr1, int nr2,
            DOUBLE *dd, DOUBLE *dr, DOUBLE *rd, DOUBLE *rr, DOUBLE *qq, DOUBLE *amps){

    printf("Computing amps\n");
    printf("qq:\n");
    for(int i=0;i<nprojbins;i++){
        for (int j=0; j<nprojbins; j++){
            printf(" %f", qq[i*nprojbins+j]);
        }
        printf("\n");
    }

    // Computer numerator of estimator
    DOUBLE numerator[nprojbins];
    DOUBLE qqnorm[nprojbins*nprojbins];
    for (int i=0; i<nprojbins; i++){
        DOUBLE ddnorm = dd[i]/((DOUBLE)nd1*(DOUBLE)nd2);
        DOUBLE drnorm = dr[i]/((DOUBLE)nd1*(DOUBLE)nr2);
        DOUBLE rdnorm = rd[i]/((DOUBLE)nr1*(DOUBLE)nd2);
        DOUBLE rrnorm = rr[i]/((DOUBLE)nr1*(DOUBLE)nr2);
        numerator[i] = ddnorm - drnorm - rdnorm + rrnorm;
        for (int j=0; j<nprojbins; j++){
            printf("%f", qq[i*nprojbins+j]);
            qqnorm[i*nprojbins+j] = qq[i*nprojbins+j]/((DOUBLE)nr1*(DOUBLE)nr2);
        }
    }

    printf("qqnorm:\n");
    for(int i=0;i<nprojbins;i++){
        for (int j=0; j<nprojbins; j++){
            printf(" %f", qqnorm[i*nprojbins+j]);
        }
        printf("\n");
    }

	int s;
	// Define all the used matrices
	gsl_matrix *qq_mat = gsl_matrix_alloc(nprojbins, nprojbins);
	gsl_matrix *qq_mat_inv = gsl_matrix_alloc(nprojbins, nprojbins);
	gsl_permutation *perm = gsl_permutation_alloc(nprojbins);
	// Fill the matrix m
	for (int i=0; i<nprojbins; i++){
        for (int j=0; j<nprojbins; j++){
            gsl_matrix_set(qq_mat, i, j, qqnorm[i*nprojbins+j]);
        }
    }
	// Make LU decomposition of matrix m
	gsl_linalg_LU_decomp(qq_mat, perm, &s);
	// Invert the matrix m
	gsl_linalg_LU_invert(qq_mat, perm, qq_mat_inv);

    printf("qqinv:\n");
    for(int i=0;i<nprojbins;i++){
        for (int j=0; j<nprojbins; j++){
            printf(" %f", gsl_matrix_get(qq_mat_inv, i, j));
        }
        printf("\n");
    }

    // Take inner product of qqinv * numerator, get amplitude vector
    // TODO: DOUBLE check
    for (int i=0; i<nprojbins; i++){
        DOUBLE aval = 0;
        for (int j=0; j<nprojbins; j++){
            aval += gsl_matrix_get(qq_mat_inv, i, j) * numerator[j];
        }
        amps[i] = aval;
    }
	return EXIT_SUCCESS;
}

int evaluate_xi_DOUBLE(int nprojbins, DOUBLE *amps, int nsvals, DOUBLE *svals,
                      int nsbins, DOUBLE *sbins, DOUBLE *xi, proj_method_t proj_method, char *projfn){

    proj_struct_DOUBLE *projdata = malloc(sizeof(proj_struct_DOUBLE));
    projdata->nprojbins = nprojbins;
	projdata->proj_method = proj_method;
 
    if (projfn != NULL) {
      FILE *projfile;
      printf("Reading in projection file, %s...\n", projfn);
      if( !(projfile=fopen(projfn,"r")) ){
        printf("ERROR opening [%s]\n",projfn);
        exit(0);
      }
      int nres = 0;
      int nbases = 0;
      char buf[1000];
      /* Count rows in file */
      while(fgets(buf, 1000, projfile)) {
        if (nres==0) {
          char *val;
          val = strtok(buf, " ");
          while (val != NULL) {
            nbases++;
            val = strtok(NULL, " ");
          }
        }
        nres++;
      }
      // to account for radii column
      nbases -= 1;
      /* Check nprojbins same as number of bases in file nbases for general_r function */
      if (nbases != nprojbins && proj_method==GENR) {
        printf("The value of nprojbins (%d) must be the same as nbases (%d), the number of columns in your basis file.\n", projdata->nprojbins, nbases);
        exit(0);
      }
      projdata->nres = nres;
      projdata->nbases = nbases;
      projdata->projbases = my_malloc(sizeof(*(projdata->projbases)), nres*(nbases+1));
      projdata->proj_method = proj_method;
      /* Read in file */
      rewind(projfile); 
      for(int i = 0; i < nres; i++){
          fgets(buf,1000,projfile);
          char *val;
          val = strtok(buf, " ");
          for(int j=0; j<nbases+1; j++){
            sscanf(val, "%lf", &projdata->projbases[i*(nbases+1)+j]);
            val = strtok(NULL, " ");
          }
      }
      fclose(projfile);
      printf("Read in %d by %d basis data\n", nres, nbases);
    }   
    
    // will need to generalize, projbins won't always be related to sbins
    DOUBLE supp_sqr[nsbins];
    //plus 1 because one more edge than number of bins
    for (int i=0; i<nsbins+1; i++){
        supp_sqr[i] = pow(sbins[i], 2);
    }

    proj_func_t_DOUBLE proj_func = get_proj_func_by_method_DOUBLE(proj_method);

    projdata->nsbins = nsbins;
    projdata->supp_sqr = supp_sqr;
    // ns: number of s values at which to evaluate xi
    for (int i=0; i<nsvals; i++){
        //get basis function u for given value of s
        DOUBLE u[nprojbins];
        DOUBLE sqr_s = pow(svals[i], 2);

        //projdata->sqr_s = sqr_s;
        //TODO: get to work!?!
        //projdata.supp = sbins;
        //proj_func(projdata, u);
        proj_func(projdata, u, sqr_s);
		/* Multiply u by the amplitudes to get xi in that s bin (xi is vector of length ns_toeval) */
        DOUBLE xival = 0;
        for (int j=0; j<nprojbins; j++){
            xival += amps[j]*u[j];
        }
        xi[i] = xival;
    }
    if (projfn!=NULL) {
      free(projdata->projbases);
    }
    free(projdata);
	return EXIT_SUCCESS;
}


