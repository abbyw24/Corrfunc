// # -*- mode: c -*-
/* File: proj_functions.c.src */
/*
  This file is an extenstion of the Corrfunc package
  Copyright (C) 2020-- Kate Storey-Fisher (kstoreyfisher@gmail.com)
  License: MIT LICENSE. See LICENSE file under the top-level
  directory at https://github.com/kstoreyf/Corrfunc/
*/

#ifndef DOUBLE_PREC
#define DOUBLE_PREC
#endif
// # -*- mode: c -*-
#pragma once

#include "proj_functions_DOUBLE.h"

#include "defs.h"
#include "utils.h"
#include "function_precision.h"

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#include <gsl/gsl_matrix_DOUBLE.h>
#include <gsl/gsl_linalg.h>
#include <gsl/gsl_interp.h>

#ifndef MAXLEN
#define MAXLEN 1000
#endif

//////////////////////////////////
// Projection functions
//////////////////////////////////

//
void tophat_DOUBLE(const proj_struct_DOUBLE *proj, DOUBLE *u, DOUBLE s, DOUBLE sqr_s){
    (void) s;//to suppress the unused variable warning

    // nsbins is number of bins and not edges
    // supp_sqr has length nsbins+1, number of edges
    for(int p=proj->nsbins-1; p>=0; p--){
        u[p] = 0;
    }
    for(int p=proj->nsbins-1; p>=0; p--){
        if (sqr_s >= proj->supp_sqr[p] && sqr_s < proj->supp_sqr[p+1]){
            u[p] = 1.0;
            break;
        }
    }
}


void piecewise_DOUBLE(const proj_struct_DOUBLE *proj, DOUBLE *u, DOUBLE s, DOUBLE sqr_s){
    (void) sqr_s;//to suppress the unused variable warning
    // Assumes nsbins = nprojbins
    for(int p=0;p<proj->nprojbins;p++){
        // peaks are bin averages, for now - need to take square roots
        double peak = 0.5*(proj->supp[p] + proj->supp[p+1]);
        // assumes bins in ascending order
        double binwidth = proj->supp[p+1] - proj->supp[p];
        double val = 1.0 - (1.0/binwidth) * FABS(s - peak);
        if (val < 0) {
            val = 0;
        }
        u[p] = val;
    }
}


void gaussian_kernel_DOUBLE(const proj_struct_DOUBLE *proj, DOUBLE *u, DOUBLE s, DOUBLE sqr_s){
    (void) sqr_s;//to suppress the unused variable warning
    double sigma = 3.0;
    double amp = 1.0/(SQRT(2.0*M_PI)*sigma);
    for(int p=0;p<proj->nprojbins;p++){
        double rp = proj->supp[p];
        if (FABS(rp-s)<4.0*sigma) {
            double gaussian = amp * exp( -0.5*( ((rp-s)/sigma)*((rp-s)/sigma)) );
            u[p] = gaussian;
        }
        else {
            u[p] = 0;
        }
    }
}


void powerlaw_DOUBLE(const proj_struct_DOUBLE *proj, DOUBLE *u, DOUBLE s, DOUBLE sqr_s){
    (void) sqr_s;//to suppress the unused variable warning
    (void) proj;

    double gamma=2.7, s0=15.0;
    double powlaw = POW(s/s0, -gamma);
    u[0] = powlaw;

    double amp=0.004, width=10, mean=107;
    double bump = amp * exp(-(s-mean)*(s-mean)/(2*width*width));
    u[1] = bump;
   
    double dwidth = amp*(s-mean)*(s-mean)/(width*width*width) * exp(-(s-mean)*(s-mean)/(2*width*width)); 
    u[2] = dwidth;
}


void general_r_DOUBLE(const proj_struct_DOUBLE *proj, DOUBLE *u, DOUBLE s, DOUBLE sqr_s){
    (void) sqr_s;//to suppress the unused variable warning
    int nbases = proj->nbases;
    int nres = proj->nres;
    DOUBLE sval;
    // TODO: somewhere check that r is in ascending order !! IMPORTANT !!

    /* if not in r range, return 0s */
    if (s<proj->projbases[0] || s>=proj->projbases[(nres-1)*(nbases+1)]){
      for (int j=0; j<nbases; j++){
        u[j] = 0;
      }
      return;
    }

    /* reverse linear search - binary may be faster? */
    int i0 = -1, i1 = -1;
    DOUBLE s0, s1, y0, y1;
    // loop backwards because last bins cover larger volume, should increase speed
    // nres-2 because nres-1 is max value, which would be caught by above case
    for (int i=nres-2; i>=0; i--){
      // get first colum of basis file, radii
      sval = proj->projbases[i*(nbases+1)];
      // >= because looping backward
      if (s >= sval) {
        i0 = i; //index before insertion location
        i1 = i+1; //index after insertion location
        s0 = sval;
        s1 = proj->projbases[i1*(nbases+1)];
        break;
      } 
    }

    for (int j=0; j<nbases; j++){
        // +1's because 0th column is sarr 
        y0 = proj->projbases[i0*(nbases+1)+(j+1)];
        y1 = proj->projbases[i1*(nbases+1)+(j+1)];
        u[j] = y0 + (s - s0)*(y1 - y0)/(s1 - s0); //linear interp
    }
}

//////////////////////////////////
// Utility functions
//////////////////////////////////

/* Gives a pointer to the projection function for the given projection method
 * and instruction set.
 */
proj_func_t_DOUBLE get_proj_func_by_method_DOUBLE(const proj_method_t method){
    switch(method){
        case TOPHAT:
            return &tophat_DOUBLE;
        case PIECEWISE:
            return &piecewise_DOUBLE;
        case POWERLAW:
            return &powerlaw_DOUBLE;
        case GENR:
            return &general_r_DOUBLE;
        case GAUSSIAN_KERNEL:
            return &gaussian_kernel_DOUBLE;
        default:
        case NONEPROJ:
            return NULL;
    }
}


int compute_amplitudes_DOUBLE(int nprojbins, int nd1, int nd2, int nr1, int nr2,
            DOUBLE *dd, DOUBLE *dr, DOUBLE *rd, DOUBLE *rr, DOUBLE *qq, DOUBLE *amps){

    // Computer numerator of estimator
    DOUBLE numerator[nprojbins];
    DOUBLE qqnorm[nprojbins*nprojbins];
    for (int i=0; i<nprojbins; i++){
        DOUBLE ddnorm = dd[i]/((DOUBLE)nd1*(DOUBLE)nd2);
        DOUBLE drnorm = dr[i]/((DOUBLE)nd1*(DOUBLE)nr2);
        DOUBLE rdnorm = rd[i]/((DOUBLE)nr1*(DOUBLE)nd2);
        DOUBLE rrnorm = rr[i]/((DOUBLE)nr1*(DOUBLE)nr2);
        numerator[i] = ddnorm - drnorm - rdnorm + rrnorm;
        for (int j=0; j<nprojbins; j++){
            qqnorm[i*nprojbins+j] = qq[i*nprojbins+j]/((DOUBLE)nr1*(DOUBLE)nr2);
        }
    }

	int s;
	// Define all the used matrices
	gsl_matrix *qq_mat = gsl_matrix_alloc(nprojbins, nprojbins);
	gsl_matrix *qq_mat_inv = gsl_matrix_alloc(nprojbins, nprojbins);
	gsl_permutation *perm = gsl_permutation_alloc(nprojbins);
	// Fill the matrix m
	for (int i=0; i<nprojbins; i++){
        for (int j=0; j<nprojbins; j++){
            gsl_matrix_set(qq_mat, i, j, qqnorm[i*nprojbins+j]);
        }
    }
	// Make LU decomposition of matrix m
	gsl_linalg_LU_decomp(qq_mat, perm, &s);
	// Invert the matrix m
	gsl_linalg_LU_invert(qq_mat, perm, qq_mat_inv);

    // Print inverse QQ matrix
    // printf("qqinv:\n");
    // for(int i=0;i<nprojbins;i++){
    //     for (int j=0; j<nprojbins; j++){
    //         printf(" %f", gsl_matrix_get(qq_mat_inv, i, j));
    //     }
    //     printf("\n");
    // }

    // Take inner product of qqinv * numerator, get amplitude vector
    // TODO: DOUBLE check
    for (int i=0; i<nprojbins; i++){
        DOUBLE aval = 0;
        for (int j=0; j<nprojbins; j++){
            aval += gsl_matrix_get(qq_mat_inv, i, j) * numerator[j];
        }
        amps[i] = aval;
    }
	return EXIT_SUCCESS;
}


int evaluate_xi_DOUBLE(int nprojbins, DOUBLE *amps, int nsvals, DOUBLE *svals,
                      int nsbins, DOUBLE *sbins, DOUBLE *xi, proj_method_t proj_method, char *projfn){

    proj_struct_DOUBLE *projdata = malloc(sizeof(proj_struct_DOUBLE));
    if(projdata == NULL){
        free(projdata);
        return EXIT_FAILURE;
    }
    projdata->nprojbins = nprojbins;
	projdata->proj_method = proj_method;

    /* Read in projection file if necessary */
    if (projfn != NULL) {
        read_projfile_DOUBLE(projfn, projdata);
    } 
    
    // will need to generalize, projbins won't always be related to sbins
    DOUBLE supp_sqr[nsbins];
    //plus 1 because one more edge than number of bins
    for (int i=0; i<nsbins+1; i++){
        supp_sqr[i] = sbins[i]*sbins[i];
    }

    proj_func_t_DOUBLE proj_func = get_proj_func_by_method_DOUBLE(proj_method);

    projdata->nsbins = nsbins;
    projdata->supp = sbins;
    projdata->supp_sqr = supp_sqr;
    // ns: number of s values at which to evaluate xi
    for (int i=0; i<nsvals; i++){
        //get basis function u for given value of s
        DOUBLE u[nprojbins];
        DOUBLE sqr_s = svals[i]*svals[i];

        proj_func(projdata, u, svals[i], sqr_s);
		/* Multiply u by the amplitudes to get xi in that s bin (xi is vector of length ns_toeval) */
        DOUBLE xival = 0;
        for (int j=0; j<nprojbins; j++){
            xival += amps[j]*u[j];
        }
        xi[i] = xival;
    }
    if (projfn!=NULL) {
      free(projdata->projbases);
    }
    free(projdata);
	return EXIT_SUCCESS;
}


int read_projfile_DOUBLE(char *projfn, proj_struct_DOUBLE *projdata){
    FILE *projfile;
    printf("Reading in projection file, %s...\n", projfn);
    projfile=fopen(projfn,"r");
    if( !projfile ){
        printf("ERROR opening [%s]\n",projfn);
        return EXIT_FAILURE;
    }
    int nres = 0;
    int nbases = 0;
    char buf[MAXLEN];
    /* Count rows in file */
    while(fgets(buf, MAXLEN, projfile)) {
        if (nres==0) {
            char *val;
            val = strtok(buf, " ");
            while (val != NULL) {
                nbases++;
                val = strtok(NULL, " ");
            }
        }
        nres++;
    }
    nbases -= 1; //to account for r column

    /* Check nprojbins same as number of bases in file nbases for general_r function */
    if (nbases != projdata->nprojbins && projdata->proj_method==GENR) {
        printf("The value of nprojbins (%ld) must be the same as nbases (%d), the number of columns in your basis file. (If off-by-one, did you forget r column in your basis file?)\n", projdata->nprojbins, nbases);
        return EXIT_FAILURE;
    }
    projdata->nres = nres;
    projdata->nbases = nbases;
    projdata->projbases = my_malloc(sizeof(*(projdata->projbases)), nres*(nbases+1));
    if(projdata->projbases == NULL){
        free(projdata->projbases);
        return EXIT_FAILURE;
    }

    /* Read in file */
    rewind(projfile);
    for(int i = 0; i < nres; i++){
        fgets(buf,MAXLEN,projfile);
        char *val;
        val = strtok(buf, " ");
        for(int j=0; j<nbases+1; j++){
            sscanf(val, "%"REAL_FORMAT, &projdata->projbases[i*(nbases+1)+j]);
            val = strtok(NULL, " ");
        }
    }
    fclose(projfile);
    printf("Read in %d by %d basis data\n", nres, nbases+1);
    return EXIT_SUCCESS;
}

DOUBLE linspace_DOUBLE(DOUBLE xmin, DOUBLE xmax, int xnum, DOUBLE* xarr){
    DOUBLE space = (xmax - xmin)/(xnum-1);
    int i;
    for (i=0; i<xnum; i++){
        xarr[i] = xmin + i*space;
    }
    return space;
}


int qq_analytic_DOUBLE(DOUBLE rmin, DOUBLE rmax, int nd, DOUBLE volume, int nprojbins, int nsbins, DOUBLE *sbins, DOUBLE *qq, proj_method_t proj_method, char *projfn){

    printf("qq analytic\n");

    proj_struct_DOUBLE *projdata = malloc(sizeof(proj_struct_DOUBLE));
    if(projdata == NULL){
        free(projdata);
        return EXIT_FAILURE;
    }
    projdata->nprojbins = nprojbins;
	projdata->proj_method = proj_method;

    /* Read in projection file if necessary */
    if (projfn != NULL) {
        read_projfile_DOUBLE(projfn, projdata);
    } 
    
    // will need to generalize, projbins won't always be related to sbins
    DOUBLE supp_sqr[nsbins];
    //plus 1 because one more edge than number of bins
    for (int i=0; i<nsbins+1; i++){
        supp_sqr[i] = sbins[i]*sbins[i];
    }

    proj_func_t_DOUBLE proj_func = get_proj_func_by_method_DOUBLE(proj_method);

    projdata->nsbins = nsbins;
    projdata->supp = sbins;
    projdata->supp_sqr = supp_sqr;

    int nrfine = 100000;
    DOUBLE dr;
    DOUBLE rfine[nrfine];
    dr = linspace_DOUBLE(rmin, rmax, nrfine, &rfine);
    DOUBLE prefac = 4*M_PI*nd*(nd-1)/volume;
    DOUBLE integrand, integral;

    for (int k=0; k<nrfine; k++){
        //get basis function u for given value of s
        DOUBLE u[nprojbins];
        DOUBLE r = rfine[k];
        DOUBLE r_sqr = r*r;
        proj_func(projdata, u, r, r_sqr);
		/* Multiply u by the amplitudes to get xi in that s bin (xi is vector of length ns_toeval) */

        for (int i=0; i<nprojbins; i++){
            for (int j=0; j<nprojbins; j++){
                integrand = r_sqr * u[i] * u[j];
                integral = integrand * dr;
                qq[i*nprojbins+j] += integral;
            }
        }
    }
    for (int i=0; i<nprojbins*nprojbins; i++){
        qq[i] *= prefac;
    }
    if (projfn!=NULL) {
      free(projdata->projbases);
    }
    free(projdata);
	return EXIT_SUCCESS;
}
