// # -*- mode: c -*-
/* File: proj_functions.h.src */
/*
  This file is a part of the Corrfunc package
  Copyright (C) 2015-- Manodeep Sinha (manodeep@gmail.com)
  License: MIT LICENSE. See LICENSE file under the top-level
  directory at https://github.com/manodeep/Corrfunc/
*/

#ifndef DOUBLE_PREC
#define DOUBLE_PREC
#endif
// # -*- mode: c -*-
#pragma once

#include "defs.h"
#include "utils.h"

#include <stdint.h>

#include <gsl/gsl_matrix_DOUBLE.h>
#include <gsl/gsl_linalg.h>

// Info about a particle pair that we will pass to the weight function
typedef struct
{
    int64_t nprojbins;
    int64_t nsbins;
    DOUBLE sqr_s;
    DOUBLE *supp_sqr; //proper way to have array in struct?

} proj_struct_DOUBLE;

//typedef DOUBLE (*weight_func_t_DOUBLE)(const pair_struct_DOUBLE*);


//////////////////////////////////
// Projection functions
//////////////////////////////////

static inline void tophat_DOUBLE(const proj_struct_DOUBLE *proj, DOUBLE *u){

    int ins = -1;
    for(int p=0;p<proj->nsbins;p++){
        u[p] = 0;
        if (proj->sqr_s >= proj->supp_sqr[p] && proj->sqr_s < proj->supp_sqr[p+1]){
            ins = p;
        }
    }
    if (ins>=0 && ins<proj->nprojbins){
        u[ins] = 1.0;
    }
}


//////////////////////////////////
// Utility functions
//////////////////////////////////

static inline void compute_amplitudes(int nprojbins, int nd1, int nd2, int nr1, int nr2,
            DOUBLE *dd, DOUBLE *dr, DOUBLE *rd, DOUBLE *rr, DOUBLE *qq, DOUBLE *amps){

    printf("Computing amps\n");
    printf("qq:\n");
    for(int i=0;i<nprojbins;i++){
        for (int j=0; j<nprojbins; j++){
            printf(" %f", qq[i*nprojbins+j]);
        }
        printf("\n");
    }

    // Computer numerator of estimator
    DOUBLE numerator[nprojbins];
    DOUBLE qqnorm[nprojbins*nprojbins];
    for (int i=0; i<nprojbins; i++){
        DOUBLE ddnorm = dd[i]/((DOUBLE)nd1*(DOUBLE)nd2);
        DOUBLE drnorm = dr[i]/((DOUBLE)nd1*(DOUBLE)nr2);
        DOUBLE rdnorm = rd[i]/((DOUBLE)nr1*(DOUBLE)nd2);
        DOUBLE rrnorm = rr[i]/((DOUBLE)nr1*(DOUBLE)nr2);
        numerator[i] = ddnorm - drnorm - rdnorm + rrnorm;
        for (int j=0; j<nprojbins; j++){
            printf("%f", qq[i*nprojbins+j]);
            qqnorm[i*nprojbins+j] = qq[i*nprojbins+j]/((DOUBLE)nr1*(DOUBLE)nr2);
        }
    }

    printf("qqnorm:\n");
    for(int i=0;i<nprojbins;i++){
        for (int j=0; j<nprojbins; j++){
            printf(" %f", qqnorm[i*nprojbins+j]);
        }
        printf("\n");
    }

	int s;
	// Define all the used matrices
	gsl_matrix *qq_mat = gsl_matrix_alloc(nprojbins, nprojbins);
	gsl_matrix *qq_mat_inv = gsl_matrix_alloc(nprojbins, nprojbins);
	gsl_permutation *perm = gsl_permutation_alloc(nprojbins);
	// Fill the matrix m
	for (int i=0; i<nprojbins; i++){
        for (int j=0; j<nprojbins; j++){
            gsl_matrix_set(qq_mat, i, j, qqnorm[i*nprojbins+j]);
        }
    }
	// Make LU decomposition of matrix m
	gsl_linalg_LU_decomp(qq_mat, perm, &s);
	// Invert the matrix m
	gsl_linalg_LU_invert(qq_mat, perm, qq_mat_inv);

    printf("qqinv:\n");
    for(int i=0;i<nprojbins;i++){
        for (int j=0; j<nprojbins; j++){
            printf(" %f", gsl_matrix_get(qq_mat_inv, i, j));
        }
        printf("\n");
    }

    // Take inner product of qqinv * numerator, get amplitude vector
    // TODO: DOUBLE check
    for (int i=0; i<nprojbins; i++){
        DOUBLE aval = 0;
        for (int j=0; j<nprojbins; j++){
            aval += gsl_matrix_get(qq_mat_inv, i, j) * numerator[j];
        }
        amps[i] = aval;
    }
}

static inline void evaluate_xi(int nprojbins, DOUBLE *amps, int nsvals, DOUBLE *svals,
                                                int nsbins, DOUBLE *sbins, DOUBLE *xi){


    // will need to generalize, projbins won't always be rela   ted to sbins
    DOUBLE supp_sqr[nsbins];
    //plus 1 because one more edge than number of bins
    for (int i=0; i<nsbins+1; i++){
        supp_sqr[i] = pow(sbins[i], 2);
    }

    // ns: number of s values at which to evaluate xi
    for (int i=0; i<nsvals; i++){
        //get basis function u for given value of s
        DOUBLE u[nprojbins];
        DOUBLE sqr_s = pow(svals[i], 2);
        proj_struct_DOUBLE projdata = {.nprojbins=nprojbins, .nsbins=nsbins, .sqr_s=sqr_s, .supp_sqr=supp_sqr};
        tophat_DOUBLE(&projdata, u);

        //multiply u by the amplitudes to get xi in that s bin (xi is vector of length ns_toeval)
        DOUBLE xival = 0;
        for (int j=0; j<nprojbins; j++){
            xival += amps[j]*u[j];

        }
        xi[i] = xival;
    }

}


/* Gives a pointer to the weight function for the given weighting method
 * and instruction set.
 */
//static inline weight_func_t_DOUBLE get_weight_func_by_method_DOUBLE(const weight_method_t method){
//    switch(method){
//        case PAIR_PRODUCT:
//            return &pair_product_DOUBLE;
//        default:
//        case NONE:
//            return NULL;
//    }
//}