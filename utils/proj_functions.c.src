// # -*- mode: c -*-
/* File: proj_functions.c.src */
/*
  This file is an extenstion of the Corrfunc package
  Copyright (C) 2020-- Kate Storey-Fisher (kstoreyfisher@gmail.com)
  License: MIT LICENSE. See LICENSE file under the top-level
  directory at https://github.com/kstoreyf/Corrfunc/
*/

#ifndef DOUBLE_PREC
#define DOUBLE_PREC
#endif
// # -*- mode: c -*-
#pragma once

#include "proj_functions_DOUBLE.h"

#include "defs.h"
#include "utils.h"

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#include <gsl/gsl_matrix_DOUBLE.h>
#include <gsl/gsl_linalg.h>
#include <gsl/gsl_interp.h>

#ifndef MAXLEN
#define MAXLEN 1000
#endif

//////////////////////////////////
// Projection functions
//////////////////////////////////

void tophat_DOUBLE(const proj_struct_DOUBLE *proj, DOUBLE *u, DOUBLE sqr_s){
    int ins = -1;
    for(int p=0;p<proj->nsbins;p++){
        u[p] = 0;
        if (sqr_s >= proj->supp_sqr[p] && sqr_s < proj->supp_sqr[p+1]){
            ins = p;
        }
    }
    if (ins>=0 && ins<proj->nprojbins){
        u[ins] = 1.0;
    }
}


void piecewise_DOUBLE(const proj_struct_DOUBLE *proj, DOUBLE *u, DOUBLE sqr_s){

    // Assumes nsbins = nprojbins
    for(int p=0;p<proj->nprojbins;p++){

        // peaks are bin averages, for now - need to take square roots
        double peak = 0.5*(sqrt(proj->supp_sqr[p]) + sqrt(proj->supp_sqr[p+1]));
        // assumes bins in ascending order
        double binwidth = sqrt(proj->supp_sqr[p+1]) - sqrt(proj->supp_sqr[p]);
        double val = 1.0 - (1.0/binwidth) * fabs(sqrt(sqr_s) - peak);
        if (val < 0) {
            val = 0;
        }
        u[p] = val;

    }
}


void gaussian_kernel_DOUBLE(const proj_struct_DOUBLE *proj, DOUBLE *u, DOUBLE sqr_s){
   double sigma = 3.0;
   double s = sqrt(sqr_s);
   double amp = 1.0/(sqrt(2.0*M_PI)*sigma);
   for(int p=0;p<proj->nprojbins;p++){
       double rp = sqrt(proj->supp_sqr[p]);
       if (abs(rp-s)<4.0*sigma) {
           double gaussian = amp * exp( -0.5* pow((rp-s) / sigma, 2.0));
           u[p] = gaussian;
       }
       else {
           u[p] = 0;
       }
   }
}


void powerlaw_DOUBLE(const proj_struct_DOUBLE *proj, DOUBLE *u, DOUBLE sqr_s){

    double s = sqrt(sqr_s);
    
    double gamma=2.7, s0=15.0;
    double powlaw = pow(s/s0, -1*gamma);
    u[0] = powlaw;

    double amp=0.004, width=10, mean=107;
    double bump = amp * exp(-1*pow(s-mean,2)/(2*pow(width,2)));
    u[1] = bump;
   
    double dwidth = amp*pow(s-mean,2)/pow(width,3) * exp(-1*pow(s-mean,2)/(2*pow(width,2))); 
    u[2] = dwidth;
}


void general_r_DOUBLE(const proj_struct_DOUBLE *proj, DOUBLE *u, DOUBLE sqr_s){

    DOUBLE s = sqrt(sqr_s);
    int nbases = proj->nbases;
    int nres = proj->nres;
    DOUBLE sval;

    // TODO: somewhere check that r is in ascending order
    /* naive search, TODO replace w binary */
    int i0 = -1, i1 = -1;
    DOUBLE s0, s1, y0, y1;
    for (int i=0; i<nres; i++){
      // get first colum of basis file, radii
      sval = proj->projbases[i*(nbases+1)];
      if (s <= sval) {
        //idx = i-1; //index before insertion location
        i0 = i-1;
        i1 = i;
        s0 = proj->projbases[i0*(nbases+1)];
        s1 = sval;

        break;
      } 
    }
    // if not in r range, return 0s
    // TODO: better to send an array of 0's and just return?
    if (i0==-1){
      for (int j=0; j<nbases; j++){
        u[j] = 0;
      }
    }
    else {
      for (int j=0; j<nbases; j++){
        // +1's because 0th column is sarr 
        y0 = proj->projbases[i0*(nbases+1)+(j+1)];
        y1 = proj->projbases[i1*(nbases+1)+(j+1)];
        u[j] = y0 + (s - s0)*(y1 - y0)/(s1 - s0); //linear interp
      }
    } 
}

//////////////////////////////////
// Utility functions
//////////////////////////////////

/* Gives a pointer to the projection function for the given projection method
 * and instruction set.
 */
proj_func_t_DOUBLE get_proj_func_by_method_DOUBLE(const proj_method_t method){
    switch(method){
        case TOPHAT:
            return &tophat_DOUBLE;
        case PIECEWISE:
            return &piecewise_DOUBLE;
        case POWERLAW:
            return &powerlaw_DOUBLE;
        case GENR:
            return &general_r_DOUBLE;
        case GAUSSIAN_KERNEL:
            return &gaussian_kernel_DOUBLE;
        default:
        case NONEPROJ:
            return NULL;
    }
}

int compute_amplitudes_DOUBLE(int nprojbins, int nd1, int nd2, int nr1, int nr2,
            DOUBLE *dd, DOUBLE *dr, DOUBLE *rd, DOUBLE *rr, DOUBLE *qq, DOUBLE *amps){

    printf("Computing amps\n");

    // Computer numerator of estimator
    DOUBLE numerator[nprojbins];
    DOUBLE qqnorm[nprojbins*nprojbins];
    for (int i=0; i<nprojbins; i++){
        DOUBLE ddnorm = dd[i]/((DOUBLE)nd1*(DOUBLE)nd2);
        DOUBLE drnorm = dr[i]/((DOUBLE)nd1*(DOUBLE)nr2);
        DOUBLE rdnorm = rd[i]/((DOUBLE)nr1*(DOUBLE)nd2);
        DOUBLE rrnorm = rr[i]/((DOUBLE)nr1*(DOUBLE)nr2);
        numerator[i] = ddnorm - drnorm - rdnorm + rrnorm;
        for (int j=0; j<nprojbins; j++){
            qqnorm[i*nprojbins+j] = qq[i*nprojbins+j]/((DOUBLE)nr1*(DOUBLE)nr2);
        }
    }

	int s;
	// Define all the used matrices
	gsl_matrix *qq_mat = gsl_matrix_alloc(nprojbins, nprojbins);
	gsl_matrix *qq_mat_inv = gsl_matrix_alloc(nprojbins, nprojbins);
	gsl_permutation *perm = gsl_permutation_alloc(nprojbins);
	// Fill the matrix m
	for (int i=0; i<nprojbins; i++){
        for (int j=0; j<nprojbins; j++){
            gsl_matrix_set(qq_mat, i, j, qqnorm[i*nprojbins+j]);
        }
    }
	// Make LU decomposition of matrix m
	gsl_linalg_LU_decomp(qq_mat, perm, &s);
	// Invert the matrix m
	gsl_linalg_LU_invert(qq_mat, perm, qq_mat_inv);

    // Print inverse QQ matrix
    // printf("qqinv:\n");
    // for(int i=0;i<nprojbins;i++){
    //     for (int j=0; j<nprojbins; j++){
    //         printf(" %f", gsl_matrix_get(qq_mat_inv, i, j));
    //     }
    //     printf("\n");
    // }

    // Take inner product of qqinv * numerator, get amplitude vector
    // TODO: DOUBLE check
    for (int i=0; i<nprojbins; i++){
        DOUBLE aval = 0;
        for (int j=0; j<nprojbins; j++){
            aval += gsl_matrix_get(qq_mat_inv, i, j) * numerator[j];
        }
        amps[i] = aval;
    }
	return EXIT_SUCCESS;
}

int evaluate_xi_DOUBLE(int nprojbins, DOUBLE *amps, int nsvals, DOUBLE *svals,
                      int nsbins, DOUBLE *sbins, DOUBLE *xi, proj_method_t proj_method, char *projfn){

    proj_struct_DOUBLE *projdata = malloc(sizeof(proj_struct_DOUBLE));
    projdata->nprojbins = nprojbins;
	projdata->proj_method = proj_method;

    /* Read in projection file if necessary */
    if (projfn != NULL) {
        read_projfile_DOUBLE(projfn, projdata);
    } 
    
    // will need to generalize, projbins won't always be related to sbins
    DOUBLE supp_sqr[nsbins];
    //plus 1 because one more edge than number of bins
    for (int i=0; i<nsbins+1; i++){
        supp_sqr[i] = pow(sbins[i], 2);
    }

    proj_func_t_DOUBLE proj_func = get_proj_func_by_method_DOUBLE(proj_method);

    projdata->nsbins = nsbins;
    projdata->supp_sqr = supp_sqr;
    // ns: number of s values at which to evaluate xi
    for (int i=0; i<nsvals; i++){
        //get basis function u for given value of s
        DOUBLE u[nprojbins];
        DOUBLE sqr_s = pow(svals[i], 2);

        //projdata->sqr_s = sqr_s;
        //TODO: get to work!?!
        //projdata.supp = sbins;
        //proj_func(projdata, u);
        proj_func(projdata, u, sqr_s);
		/* Multiply u by the amplitudes to get xi in that s bin (xi is vector of length ns_toeval) */
        DOUBLE xival = 0;
        for (int j=0; j<nprojbins; j++){
            xival += amps[j]*u[j];
        }
        xi[i] = xival;
    }
    if (projfn!=NULL) {
      free(projdata->projbases);
    }
    free(projdata);
	return EXIT_SUCCESS;
}


int read_projfile_DOUBLE(char *projfn, proj_struct_DOUBLE *projdata){
    FILE *projfile;
    printf("Reading in projection file, %s...\n", projfn);
    projfile=fopen(projfn,"r");
    if( !projfile ){
        printf("ERROR opening [%s]\n",projfn);
        exit(0);
    }
    int nres = 0;
    int nbases = 0;
    char buf[MAXLEN];
    /* Count rows in file */
    while(fgets(buf, MAXLEN, projfile)) {
        if (nres==0) {
            char *val;
            val = strtok(buf, " ");
            while (val != NULL) {
                nbases++;
                val = strtok(NULL, " ");
            }
        }
        nres++;
    }
    nbases -= 1; //to account for r column

    /* Check nprojbins same as number of bases in file nbases for general_r function */
    if (nbases != projdata->nprojbins && projdata->proj_method==GENR) {
        printf("The value of nprojbins (%d) must be the same as nbases (%d), the number of columns in your basis file. (If off-by-one, did you forget r column in your basis file?)\n", projdata->nprojbins, nbases);
        exit(0);
    }
    projdata->nres = nres;
    projdata->nbases = nbases;
    projdata->projbases = my_malloc(sizeof(*(projdata->projbases)), nres*(nbases+1));
    /* Read in file */
    rewind(projfile);
    for(int i = 0; i < nres; i++){
        fgets(buf,1000,projfile);
        char *val;
        val = strtok(buf, " ");
        for(int j=0; j<nbases+1; j++){
            sscanf(val, "%lf", &projdata->projbases[i*(nbases+1)+j]);
            val = strtok(NULL, " ");
        }
    }
    fclose(projfile);
    printf("Read in %d by %d basis data\n", nres, nbases+1);
}
